{
  "version": 3,
  "sources": ["../../../../../node_modules/.pnpm/lit-html@3.2.1/node_modules/lit-html/src/directives/repeat.ts", "../../../../../node_modules/.pnpm/lit-html@3.2.1/node_modules/lit-html/src/directives/live.ts", "../../../../../node_modules/.pnpm/hotkeys-js@3.13.9/node_modules/hotkeys-js/dist/hotkeys.esm.js", "../../../../../src/ninja-keys.js"],
  "sourcesContent": ["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {ChildPart, noChange} from '../lit-html.js';\nimport {directive, Directive, PartInfo, PartType} from '../directive.js';\nimport {\n  insertPart,\n  getCommittedValue,\n  removePart,\n  setCommittedValue,\n  setChildPartValue,\n} from '../directive-helpers.js';\n\nexport type KeyFn<T> = (item: T, index: number) => unknown;\nexport type ItemTemplate<T> = (item: T, index: number) => unknown;\n\n// Helper for generating a map of array item to its index over a subset\n// of an array (used to lazily generate `newKeyToIndexMap` and\n// `oldKeyToIndexMap`)\nconst generateMap = (list: unknown[], start: number, end: number) => {\n  const map = new Map<unknown, number>();\n  for (let i = start; i <= end; i++) {\n    map.set(list[i], i);\n  }\n  return map;\n};\n\nclass RepeatDirective extends Directive {\n  private _itemKeys?: unknown[];\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.CHILD) {\n      throw new Error('repeat() can only be used in text expressions');\n    }\n  }\n\n  private _getValuesAndKeys<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    let keyFn: KeyFn<T> | undefined;\n    if (template === undefined) {\n      template = keyFnOrTemplate;\n    } else if (keyFnOrTemplate !== undefined) {\n      keyFn = keyFnOrTemplate as KeyFn<T>;\n    }\n    const keys = [];\n    const values = [];\n    let index = 0;\n    for (const item of items) {\n      keys[index] = keyFn ? keyFn(item, index) : index;\n      values[index] = template!(item, index);\n      index++;\n    }\n    return {\n      values,\n      keys,\n    };\n  }\n\n  render<T>(items: Iterable<T>, template: ItemTemplate<T>): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): Array<unknown>;\n  render<T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ) {\n    return this._getValuesAndKeys(items, keyFnOrTemplate, template).values;\n  }\n\n  override update<T>(\n    containerPart: ChildPart,\n    [items, keyFnOrTemplate, template]: [\n      Iterable<T>,\n      KeyFn<T> | ItemTemplate<T>,\n      ItemTemplate<T>,\n    ]\n  ) {\n    // Old part & key lists are retrieved from the last update (which may\n    // be primed by hydration)\n    const oldParts = getCommittedValue(\n      containerPart\n    ) as Array<ChildPart | null>;\n    const {values: newValues, keys: newKeys} = this._getValuesAndKeys(\n      items,\n      keyFnOrTemplate,\n      template\n    );\n\n    // We check that oldParts, the committed value, is an Array as an\n    // indicator that the previous value came from a repeat() call. If\n    // oldParts is not an Array then this is the first render and we return\n    // an array for lit-html's array handling to render, and remember the\n    // keys.\n    if (!Array.isArray(oldParts)) {\n      this._itemKeys = newKeys;\n      return newValues;\n    }\n\n    // In SSR hydration it's possible for oldParts to be an array but for us\n    // to not have item keys because the update() hasn't run yet. We set the\n    // keys to an empty array. This will cause all oldKey/newKey comparisons\n    // to fail and execution to fall to the last nested brach below which\n    // reuses the oldPart.\n    const oldKeys = (this._itemKeys ??= []);\n\n    // New part list will be built up as we go (either reused from\n    // old parts or created for new keys in this update). This is\n    // saved in the above cache at the end of the update.\n    const newParts: ChildPart[] = [];\n\n    // Maps from key to index for current and previous update; these\n    // are generated lazily only when needed as a performance\n    // optimization, since they are only required for multiple\n    // non-contiguous changes in the list, which are less common.\n    let newKeyToIndexMap!: Map<unknown, number>;\n    let oldKeyToIndexMap!: Map<unknown, number>;\n\n    // Head and tail pointers to old parts and new values\n    let oldHead = 0;\n    let oldTail = oldParts.length - 1;\n    let newHead = 0;\n    let newTail = newValues.length - 1;\n\n    // Overview of O(n) reconciliation algorithm (general approach\n    // based on ideas found in ivi, vue, snabbdom, etc.):\n    //\n    // * We start with the list of old parts and new values (and\n    //   arrays of their respective keys), head/tail pointers into\n    //   each, and we build up the new list of parts by updating\n    //   (and when needed, moving) old parts or creating new ones.\n    //   The initial scenario might look like this (for brevity of\n    //   the diagrams, the numbers in the array reflect keys\n    //   associated with the old parts or new values, although keys\n    //   and parts/values are actually stored in parallel arrays\n    //   indexed using the same head/tail pointers):\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [ ,  ,  ,  ,  ,  ,  ]\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6] <- reflects the user's new\n    //                                      item order\n    //      newHead ^                 ^ newTail\n    //\n    // * Iterate old & new lists from both sides, updating,\n    //   swapping, or removing parts at the head/tail locations\n    //   until neither head nor tail can move.\n    //\n    // * Example below: keys at head pointers match, so update old\n    //   part 0 in-place (no need to move it) and record part 0 in\n    //   the `newParts` list. The last thing we do is advance the\n    //   `oldHead` and `newHead` pointers (will be reflected in the\n    //   next diagram).\n    //\n    //      oldHead v                 v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  ,  ] <- heads matched: update 0\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //      newHead ^                 ^ newTail\n    //\n    // * Example below: head pointers don't match, but tail\n    //   pointers do, so update part 6 in place (no need to move\n    //   it), and record part 6 in the `newParts` list. Last,\n    //   advance the `oldTail` and `oldHead` pointers.\n    //\n    //         oldHead v              v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- tails matched: update 6\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldTail\n    //                                      & newTail\n    //         newHead ^              ^ newTail\n    //\n    // * If neither head nor tail match; next check if one of the\n    //   old head/tail items was removed. We first need to generate\n    //   the reverse map of new keys to index (`newKeyToIndexMap`),\n    //   which is done once lazily as a performance optimization,\n    //   since we only hit this case if multiple non-contiguous\n    //   changes were made. Note that for contiguous removal\n    //   anywhere in the list, the head and tails would advance\n    //   from either end and pass each other before we get to this\n    //   case and removals would be handled in the final while loop\n    //   without needing to generate the map.\n    //\n    // * Example below: The key at `oldTail` was removed (no longer\n    //   in the `newKeyToIndexMap`), so remove that part from the\n    //   DOM and advance just the `oldTail` pointer.\n    //\n    //         oldHead v           v oldTail\n    //   oldKeys:  [0, 1, 2, 3, 4, 5, 6]\n    //   newParts: [0,  ,  ,  ,  ,  , 6] <- 5 not in new map: remove\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    5 and advance oldTail\n    //         newHead ^           ^ newTail\n    //\n    // * Once head and tail cannot move, any mismatches are due to\n    //   either new or moved items; if a new key is in the previous\n    //   \"old key to old index\" map, move the old part to the new\n    //   location, otherwise create and insert a new part. Note\n    //   that when moving an old part we null its position in the\n    //   oldParts array if it lies between the head and tail so we\n    //   know to skip it when the pointers get there.\n    //\n    // * Example below: neither head nor tail match, and neither\n    //   were removed; so find the `newHead` key in the\n    //   `oldKeyToIndexMap`, and move that old part's DOM into the\n    //   next head position (before `oldParts[oldHead]`). Last,\n    //   null the part in the `oldPart` array since it was\n    //   somewhere in the remaining oldParts still to be scanned\n    //   (between the head and tail pointers) so that we know to\n    //   skip that old part on future iterations.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2,  ,  ,  ,  , 6] <- stuck: update & move 2\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    into place and advance\n    //                                      newHead\n    //         newHead ^           ^ newTail\n    //\n    // * Note that for moves/insertions like the one above, a part\n    //   inserted at the head pointer is inserted before the\n    //   current `oldParts[oldHead]`, and a part inserted at the\n    //   tail pointer is inserted before `newParts[newTail+1]`. The\n    //   seeming asymmetry lies in the fact that new parts are\n    //   moved into place outside in, so to the right of the head\n    //   pointer are old parts, and to the right of the tail\n    //   pointer are new parts.\n    //\n    // * We always restart back from the top of the algorithm,\n    //   allowing matching and simple updates in place to\n    //   continue...\n    //\n    // * Example below: the head pointers once again match, so\n    //   simply update part 1 and record it in the `newParts`\n    //   array.  Last, advance both head pointers.\n    //\n    //         oldHead v        v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1,  ,  ,  , 6] <- heads matched: update 1\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance both oldHead\n    //                                      & newHead\n    //            newHead ^        ^ newTail\n    //\n    // * As mentioned above, items that were moved as a result of\n    //   being stuck (the final else clause in the code below) are\n    //   marked with null, so we always advance old pointers over\n    //   these so we're comparing the next actual old value on\n    //   either end.\n    //\n    // * Example below: `oldHead` is null (already placed in\n    //   newParts), so advance `oldHead`.\n    //\n    //            oldHead v     v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6] <- old head already used:\n    //   newParts: [0, 2, 1,  ,  ,  , 6]    advance oldHead\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //               newHead ^     ^ newTail\n    //\n    // * Note it's not critical to mark old parts as null when they\n    //   are moved from head to tail or tail to head, since they\n    //   will be outside the pointer range and never visited again.\n    //\n    // * Example below: Here the old tail key matches the new head\n    //   key, so the part at the `oldTail` position and move its\n    //   DOM to the new head position (before `oldParts[oldHead]`).\n    //   Last, advance `oldTail` and `newHead` pointers.\n    //\n    //               oldHead v  v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4,  ,  , 6] <- old tail matches new\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]   head: update & move 4,\n    //                                     advance oldTail & newHead\n    //               newHead ^     ^ newTail\n    //\n    // * Example below: Old and new head keys match, so update the\n    //   old head part in place, and advance the `oldHead` and\n    //   `newHead` pointers.\n    //\n    //               oldHead v oldTail\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3,   ,6] <- heads match: update 3\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]    and advance oldHead &\n    //                                      newHead\n    //                  newHead ^  ^ newTail\n    //\n    // * Once the new or old pointers move past each other then all\n    //   we have left is additions (if old list exhausted) or\n    //   removals (if new list exhausted). Those are handled in the\n    //   final while loops at the end.\n    //\n    // * Example below: `oldHead` exceeded `oldTail`, so we're done\n    //   with the main loop.  Create the remaining part and insert\n    //   it at the new head position, and the update is complete.\n    //\n    //                   (oldHead > oldTail)\n    //   oldKeys:  [0, 1, -, 3, 4, 5, 6]\n    //   newParts: [0, 2, 1, 4, 3, 7 ,6] <- create and insert 7\n    //   newKeys:  [0, 2, 1, 4, 3, 7, 6]\n    //                     newHead ^ newTail\n    //\n    // * Note that the order of the if/else clauses is not\n    //   important to the algorithm, as long as the null checks\n    //   come first (to ensure we're always working on valid old\n    //   parts) and that the final else clause comes last (since\n    //   that's where the expensive moves occur). The order of\n    //   remaining clauses is just a simple guess at which cases\n    //   will be most common.\n    //\n    // * Note, we could calculate the longest\n    //   increasing subsequence (LIS) of old items in new position,\n    //   and only move those not in the LIS set. However that costs\n    //   O(nlogn) time and adds a bit more code, and only helps\n    //   make rare types of mutations require fewer moves. The\n    //   above handles removes, adds, reversal, swaps, and single\n    //   moves of contiguous items in linear time, in the minimum\n    //   number of moves. As the number of multiple moves where LIS\n    //   might help approaches a random shuffle, the LIS\n    //   optimization becomes less helpful, so it seems not worth\n    //   the code at this point. Could reconsider if a compelling\n    //   case arises.\n\n    while (oldHead <= oldTail && newHead <= newTail) {\n      if (oldParts[oldHead] === null) {\n        // `null` means old part at head has already been used\n        // below; skip\n        oldHead++;\n      } else if (oldParts[oldTail] === null) {\n        // `null` means old part at tail has already been used\n        // below; skip\n        oldTail--;\n      } else if (oldKeys[oldHead] === newKeys[newHead]) {\n        // Old head matches new head; update in place\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newHead]\n        );\n        oldHead++;\n        newHead++;\n      } else if (oldKeys[oldTail] === newKeys[newTail]) {\n        // Old tail matches new tail; update in place\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newTail]\n        );\n        oldTail--;\n        newTail--;\n      } else if (oldKeys[oldHead] === newKeys[newTail]) {\n        // Old head matches new tail; update and move to new tail\n        newParts[newTail] = setChildPartValue(\n          oldParts[oldHead]!,\n          newValues[newTail]\n        );\n        insertPart(containerPart, newParts[newTail + 1], oldParts[oldHead]!);\n        oldHead++;\n        newTail--;\n      } else if (oldKeys[oldTail] === newKeys[newHead]) {\n        // Old tail matches new head; update and move to new head\n        newParts[newHead] = setChildPartValue(\n          oldParts[oldTail]!,\n          newValues[newHead]\n        );\n        insertPart(containerPart, oldParts[oldHead]!, oldParts[oldTail]!);\n        oldTail--;\n        newHead++;\n      } else {\n        if (newKeyToIndexMap === undefined) {\n          // Lazily generate key-to-index maps, used for removals &\n          // moves below\n          newKeyToIndexMap = generateMap(newKeys, newHead, newTail);\n          oldKeyToIndexMap = generateMap(oldKeys, oldHead, oldTail);\n        }\n        if (!newKeyToIndexMap.has(oldKeys[oldHead])) {\n          // Old head is no longer in new list; remove\n          removePart(oldParts[oldHead]!);\n          oldHead++;\n        } else if (!newKeyToIndexMap.has(oldKeys[oldTail])) {\n          // Old tail is no longer in new list; remove\n          removePart(oldParts[oldTail]!);\n          oldTail--;\n        } else {\n          // Any mismatches at this point are due to additions or\n          // moves; see if we have an old part we can reuse and move\n          // into place\n          const oldIndex = oldKeyToIndexMap.get(newKeys[newHead]);\n          const oldPart = oldIndex !== undefined ? oldParts[oldIndex] : null;\n          if (oldPart === null) {\n            // No old part for this value; create a new one and\n            // insert it\n            const newPart = insertPart(containerPart, oldParts[oldHead]!);\n            setChildPartValue(newPart, newValues[newHead]);\n            newParts[newHead] = newPart;\n          } else {\n            // Reuse old part\n            newParts[newHead] = setChildPartValue(oldPart, newValues[newHead]);\n            insertPart(containerPart, oldParts[oldHead]!, oldPart);\n            // This marks the old part as having been used, so that\n            // it will be skipped in the first two checks above\n            oldParts[oldIndex as number] = null;\n          }\n          newHead++;\n        }\n      }\n    }\n    // Add parts for any remaining new values\n    while (newHead <= newTail) {\n      // For all remaining additions, we insert before last new\n      // tail, since old pointers are no longer valid\n      const newPart = insertPart(containerPart, newParts[newTail + 1]);\n      setChildPartValue(newPart, newValues[newHead]);\n      newParts[newHead++] = newPart;\n    }\n    // Remove any remaining unused old parts\n    while (oldHead <= oldTail) {\n      const oldPart = oldParts[oldHead++];\n      if (oldPart !== null) {\n        removePart(oldPart);\n      }\n    }\n\n    // Save order of new parts for next round\n    this._itemKeys = newKeys;\n    // Directly set part value, bypassing it's dirty-checking\n    setCommittedValue(containerPart, newParts);\n    return noChange;\n  }\n}\n\nexport interface RepeatDirectiveFn {\n  <T>(\n    items: Iterable<T>,\n    keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>,\n    template?: ItemTemplate<T>\n  ): unknown;\n  <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;\n  <T>(\n    items: Iterable<T>,\n    keyFn: KeyFn<T> | ItemTemplate<T>,\n    template: ItemTemplate<T>\n  ): unknown;\n}\n\n/**\n * A directive that repeats a series of values (usually `TemplateResults`)\n * generated from an iterable, and updates those items efficiently when the\n * iterable changes based on user-provided `keys` associated with each item.\n *\n * Note that if a `keyFn` is provided, strict key-to-DOM mapping is maintained,\n * meaning previous DOM for a given key is moved into the new position if\n * needed, and DOM will never be reused with values for different keys (new DOM\n * will always be created for new keys). This is generally the most efficient\n * way to use `repeat` since it performs minimum unnecessary work for insertions\n * and removals.\n *\n * The `keyFn` takes two parameters, the item and its index, and returns a unique key value.\n *\n * ```js\n * html`\n *   <ol>\n *     ${repeat(this.items, (item) => item.id, (item, index) => {\n *       return html`<li>${index}: ${item.name}</li>`;\n *     })}\n *   </ol>\n * `\n * ```\n *\n * **Important**: If providing a `keyFn`, keys *must* be unique for all items in a\n * given call to `repeat`. The behavior when two or more items have the same key\n * is undefined.\n *\n * If no `keyFn` is provided, this directive will perform similar to mapping\n * items to values, and DOM will be reused against potentially different items.\n */\nexport const repeat = directive(RepeatDirective) as RepeatDirectiveFn;\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {RepeatDirective};\n", "/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {AttributePart, noChange, nothing} from '../lit-html.js';\nimport {\n  directive,\n  Directive,\n  DirectiveParameters,\n  PartInfo,\n  PartType,\n} from '../directive.js';\nimport {isSingleExpression, setCommittedValue} from '../directive-helpers.js';\n\nclass LiveDirective extends Directive {\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (\n      !(\n        partInfo.type === PartType.PROPERTY ||\n        partInfo.type === PartType.ATTRIBUTE ||\n        partInfo.type === PartType.BOOLEAN_ATTRIBUTE\n      )\n    ) {\n      throw new Error(\n        'The `live` directive is not allowed on child or event bindings'\n      );\n    }\n    if (!isSingleExpression(partInfo)) {\n      throw new Error('`live` bindings can only contain a single expression');\n    }\n  }\n\n  render(value: unknown) {\n    return value;\n  }\n\n  override update(part: AttributePart, [value]: DirectiveParameters<this>) {\n    if (value === noChange || value === nothing) {\n      return value;\n    }\n    const element = part.element;\n    const name = part.name;\n\n    if (part.type === PartType.PROPERTY) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (value === (element as any)[name]) {\n        return noChange;\n      }\n    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {\n      if (!!value === element.hasAttribute(name)) {\n        return noChange;\n      }\n    } else if (part.type === PartType.ATTRIBUTE) {\n      if (element.getAttribute(name) === String(value)) {\n        return noChange;\n      }\n    }\n    // Resets the part's value, causing its dirty-check to fail so that it\n    // always sets the value.\n    setCommittedValue(part);\n    return value;\n  }\n}\n\n/**\n * Checks binding values against live DOM values, instead of previously bound\n * values, when determining whether to update the value.\n *\n * This is useful for cases where the DOM value may change from outside of\n * lit-html, such as with a binding to an `<input>` element's `value` property,\n * a content editable elements text, or to a custom element that changes it's\n * own properties or attributes.\n *\n * In these cases if the DOM value changes, but the value set through lit-html\n * bindings hasn't, lit-html won't know to update the DOM value and will leave\n * it alone. If this is not what you want--if you want to overwrite the DOM\n * value with the bound value no matter what--use the `live()` directive:\n *\n * ```js\n * html`<input .value=${live(x)}>`\n * ```\n *\n * `live()` performs a strict equality check against the live DOM value, and if\n * the new value is equal to the live value, does nothing. This means that\n * `live()` should not be used when the binding will cause a type conversion. If\n * you use `live()` with an attribute binding, make sure that only strings are\n * passed in, or the binding will update every render.\n */\nexport const live = directive(LiveDirective);\n\n/**\n * The type of the class that powers this directive. Necessary for naming the\n * directive's return type.\n */\nexport type {LiveDirective};\n", "/**! \n * hotkeys-js v3.13.9 \n * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies. \n * \n * Copyright (c) 2024 kenny wong <wowohoo@qq.com> \n * https://github.com/jaywcjlove/hotkeys-js.git \n * \n * @website: https://jaywcjlove.github.io/hotkeys-js\n \n * Licensed under the MIT license \n */\n\nconst isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false;\n\n// \u7ED1\u5B9A\u4E8B\u4EF6\nfunction addEvent(object, event, method, useCapture) {\n  if (object.addEventListener) {\n    object.addEventListener(event, method, useCapture);\n  } else if (object.attachEvent) {\n    object.attachEvent(\"on\".concat(event), method);\n  }\n}\nfunction removeEvent(object, event, method, useCapture) {\n  if (object.removeEventListener) {\n    object.removeEventListener(event, method, useCapture);\n  } else if (object.detachEvent) {\n    object.detachEvent(\"on\".concat(event), method);\n  }\n}\n\n// \u4FEE\u9970\u952E\u8F6C\u6362\u6210\u5BF9\u5E94\u7684\u952E\u7801\nfunction getMods(modifier, key) {\n  const mods = key.slice(0, key.length - 1);\n  for (let i = 0; i < mods.length; i++) mods[i] = modifier[mods[i].toLowerCase()];\n  return mods;\n}\n\n// \u5904\u7406\u4F20\u7684key\u5B57\u7B26\u4E32\u8F6C\u6362\u6210\u6570\u7EC4\nfunction getKeys(key) {\n  if (typeof key !== 'string') key = '';\n  key = key.replace(/\\s/g, ''); // \u5339\u914D\u4EFB\u4F55\u7A7A\u767D\u5B57\u7B26,\u5305\u62EC\u7A7A\u683C\u3001\u5236\u8868\u7B26\u3001\u6362\u9875\u7B26\u7B49\u7B49\n  const keys = key.split(','); // \u540C\u65F6\u8BBE\u7F6E\u591A\u4E2A\u5FEB\u6377\u952E\uFF0C\u4EE5','\u5206\u5272\n  let index = keys.lastIndexOf('');\n\n  // \u5FEB\u6377\u952E\u53EF\u80FD\u5305\u542B','\uFF0C\u9700\u7279\u6B8A\u5904\u7406\n  for (; index >= 0;) {\n    keys[index - 1] += ',';\n    keys.splice(index, 1);\n    index = keys.lastIndexOf('');\n  }\n  return keys;\n}\n\n// \u6BD4\u8F83\u4FEE\u9970\u952E\u7684\u6570\u7EC4\nfunction compareArray(a1, a2) {\n  const arr1 = a1.length >= a2.length ? a1 : a2;\n  const arr2 = a1.length >= a2.length ? a2 : a1;\n  let isIndex = true;\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;\n  }\n  return isIndex;\n}\n\n// Special Keys\nconst _keyMap = {\n  backspace: 8,\n  '\u232B': 8,\n  tab: 9,\n  clear: 12,\n  enter: 13,\n  '\u21A9': 13,\n  return: 13,\n  esc: 27,\n  escape: 27,\n  space: 32,\n  left: 37,\n  up: 38,\n  right: 39,\n  down: 40,\n  del: 46,\n  delete: 46,\n  ins: 45,\n  insert: 45,\n  home: 36,\n  end: 35,\n  pageup: 33,\n  pagedown: 34,\n  capslock: 20,\n  num_0: 96,\n  num_1: 97,\n  num_2: 98,\n  num_3: 99,\n  num_4: 100,\n  num_5: 101,\n  num_6: 102,\n  num_7: 103,\n  num_8: 104,\n  num_9: 105,\n  num_multiply: 106,\n  num_add: 107,\n  num_enter: 108,\n  num_subtract: 109,\n  num_decimal: 110,\n  num_divide: 111,\n  '\u21EA': 20,\n  ',': 188,\n  '.': 190,\n  '/': 191,\n  '`': 192,\n  '-': isff ? 173 : 189,\n  '=': isff ? 61 : 187,\n  ';': isff ? 59 : 186,\n  '\\'': 222,\n  '[': 219,\n  ']': 221,\n  '\\\\': 220\n};\n\n// Modifier Keys\nconst _modifier = {\n  // shiftKey\n  '\u21E7': 16,\n  shift: 16,\n  // altKey\n  '\u2325': 18,\n  alt: 18,\n  option: 18,\n  // ctrlKey\n  '\u2303': 17,\n  ctrl: 17,\n  control: 17,\n  // metaKey\n  '\u2318': 91,\n  cmd: 91,\n  command: 91\n};\nconst modifierMap = {\n  16: 'shiftKey',\n  18: 'altKey',\n  17: 'ctrlKey',\n  91: 'metaKey',\n  shiftKey: 16,\n  ctrlKey: 17,\n  altKey: 18,\n  metaKey: 91\n};\nconst _mods = {\n  16: false,\n  18: false,\n  17: false,\n  91: false\n};\nconst _handlers = {};\n\n// F1~F12 special key\nfor (let k = 1; k < 20; k++) {\n  _keyMap[\"f\".concat(k)] = 111 + k;\n}\n\nlet _downKeys = []; // \u8BB0\u5F55\u6441\u4E0B\u7684\u7ED1\u5B9A\u952E\nlet winListendFocus = null; // window\u662F\u5426\u5DF2\u7ECF\u76D1\u542C\u4E86focus\u4E8B\u4EF6\nlet _scope = 'all'; // \u9ED8\u8BA4\u70ED\u952E\u8303\u56F4\nconst elementEventMap = new Map(); // \u5DF2\u7ED1\u5B9A\u4E8B\u4EF6\u7684\u8282\u70B9\u8BB0\u5F55\n\n// \u8FD4\u56DE\u952E\u7801\nconst code = x => _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);\nconst getKey = x => Object.keys(_keyMap).find(k => _keyMap[k] === x);\nconst getModifier = x => Object.keys(_modifier).find(k => _modifier[k] === x);\n\n// \u8BBE\u7F6E\u83B7\u53D6\u5F53\u524D\u8303\u56F4\uFF08\u9ED8\u8BA4\u4E3A'\u6240\u6709'\uFF09\nfunction setScope(scope) {\n  _scope = scope || 'all';\n}\n// \u83B7\u53D6\u5F53\u524D\u8303\u56F4\nfunction getScope() {\n  return _scope || 'all';\n}\n// \u83B7\u53D6\u6441\u4E0B\u7ED1\u5B9A\u952E\u7684\u952E\u503C\nfunction getPressedKeyCodes() {\n  return _downKeys.slice(0);\n}\nfunction getPressedKeyString() {\n  return _downKeys.map(c => getKey(c) || getModifier(c) || String.fromCharCode(c));\n}\nfunction getAllKeyCodes() {\n  const result = [];\n  Object.keys(_handlers).forEach(k => {\n    _handlers[k].forEach(_ref => {\n      let {\n        key,\n        scope,\n        mods,\n        shortcut\n      } = _ref;\n      result.push({\n        scope,\n        shortcut,\n        mods,\n        keys: key.split('+').map(v => code(v))\n      });\n    });\n  });\n  return result;\n}\n\n// \u8868\u5355\u63A7\u4EF6\u63A7\u4EF6\u5224\u65AD \u8FD4\u56DE Boolean\n// hotkey is effective only when filter return true\nfunction filter(event) {\n  const target = event.target || event.srcElement;\n  const {\n    tagName\n  } = target;\n  let flag = true;\n  const isInput = tagName === 'INPUT' && !['checkbox', 'radio', 'range', 'button', 'file', 'reset', 'submit', 'color'].includes(target.type);\n  // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>\n  if (target.isContentEditable || (isInput || tagName === 'TEXTAREA' || tagName === 'SELECT') && !target.readOnly) {\n    flag = false;\n  }\n  return flag;\n}\n\n// \u5224\u65AD\u6441\u4E0B\u7684\u952E\u662F\u5426\u4E3A\u67D0\u4E2A\u952E\uFF0C\u8FD4\u56DEtrue\u6216\u8005false\nfunction isPressed(keyCode) {\n  if (typeof keyCode === 'string') {\n    keyCode = code(keyCode); // \u8F6C\u6362\u6210\u952E\u7801\n  }\n  return _downKeys.indexOf(keyCode) !== -1;\n}\n\n// \u5FAA\u73AF\u5220\u9664handlers\u4E2D\u7684\u6240\u6709 scope(\u8303\u56F4)\nfunction deleteScope(scope, newScope) {\n  let handlers;\n  let i;\n\n  // \u6CA1\u6709\u6307\u5B9Ascope\uFF0C\u83B7\u53D6scope\n  if (!scope) scope = getScope();\n  for (const key in _handlers) {\n    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {\n      handlers = _handlers[key];\n      for (i = 0; i < handlers.length;) {\n        if (handlers[i].scope === scope) {\n          const deleteItems = handlers.splice(i, 1);\n          deleteItems.forEach(_ref2 => {\n            let {\n              element\n            } = _ref2;\n            return removeKeyEvent(element);\n          });\n        } else {\n          i++;\n        }\n      }\n    }\n  }\n\n  // \u5982\u679Cscope\u88AB\u5220\u9664\uFF0C\u5C06scope\u91CD\u7F6E\u4E3Aall\n  if (getScope() === scope) setScope(newScope || 'all');\n}\n\n// \u6E05\u9664\u4FEE\u9970\u952E\nfunction clearModifier(event) {\n  let key = event.keyCode || event.which || event.charCode;\n  const i = _downKeys.indexOf(key);\n\n  // \u4ECE\u5217\u8868\u4E2D\u6E05\u9664\u6309\u538B\u8FC7\u7684\u952E\n  if (i >= 0) {\n    _downKeys.splice(i, 1);\n  }\n  // \u7279\u6B8A\u5904\u7406 cmmand \u952E\uFF0C\u5728 cmmand \u7EC4\u5408\u5FEB\u6377\u952E keyup \u53EA\u6267\u884C\u4E00\u6B21\u7684\u95EE\u9898\n  if (event.key && event.key.toLowerCase() === 'meta') {\n    _downKeys.splice(0, _downKeys.length);\n  }\n\n  // \u4FEE\u9970\u952E shiftKey altKey ctrlKey (command||metaKey) \u6E05\u9664\n  if (key === 93 || key === 224) key = 91;\n  if (key in _mods) {\n    _mods[key] = false;\n\n    // \u5C06\u4FEE\u9970\u952E\u91CD\u7F6E\u4E3Afalse\n    for (const k in _modifier) if (_modifier[k] === key) hotkeys[k] = false;\n  }\n}\nfunction unbind(keysInfo) {\n  // unbind(), unbind all keys\n  if (typeof keysInfo === 'undefined') {\n    Object.keys(_handlers).forEach(key => {\n      Array.isArray(_handlers[key]) && _handlers[key].forEach(info => eachUnbind(info));\n      delete _handlers[key];\n    });\n    removeKeyEvent(null);\n  } else if (Array.isArray(keysInfo)) {\n    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])\n    keysInfo.forEach(info => {\n      if (info.key) eachUnbind(info);\n    });\n  } else if (typeof keysInfo === 'object') {\n    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})\n    if (keysInfo.key) eachUnbind(keysInfo);\n  } else if (typeof keysInfo === 'string') {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // support old method\n    // eslint-disable-line\n    let [scope, method] = args;\n    if (typeof scope === 'function') {\n      method = scope;\n      scope = '';\n    }\n    eachUnbind({\n      key: keysInfo,\n      scope,\n      method,\n      splitKey: '+'\n    });\n  }\n}\n\n// \u89E3\u9664\u7ED1\u5B9A\u67D0\u4E2A\u8303\u56F4\u7684\u5FEB\u6377\u952E\nconst eachUnbind = _ref3 => {\n  let {\n    key,\n    scope,\n    method,\n    splitKey = '+'\n  } = _ref3;\n  const multipleKeys = getKeys(key);\n  multipleKeys.forEach(originKey => {\n    const unbindKeys = originKey.split(splitKey);\n    const len = unbindKeys.length;\n    const lastKey = unbindKeys[len - 1];\n    const keyCode = lastKey === '*' ? '*' : code(lastKey);\n    if (!_handlers[keyCode]) return;\n    // \u5224\u65AD\u662F\u5426\u4F20\u5165\u8303\u56F4\uFF0C\u6CA1\u6709\u5C31\u83B7\u53D6\u8303\u56F4\n    if (!scope) scope = getScope();\n    const mods = len > 1 ? getMods(_modifier, unbindKeys) : [];\n    const unbindElements = [];\n    _handlers[keyCode] = _handlers[keyCode].filter(record => {\n      // \u901A\u8FC7\u51FD\u6570\u5224\u65AD\uFF0C\u662F\u5426\u89E3\u9664\u7ED1\u5B9A\uFF0C\u51FD\u6570\u76F8\u7B49\u76F4\u63A5\u8FD4\u56DE\n      const isMatchingMethod = method ? record.method === method : true;\n      const isUnbind = isMatchingMethod && record.scope === scope && compareArray(record.mods, mods);\n      if (isUnbind) unbindElements.push(record.element);\n      return !isUnbind;\n    });\n    unbindElements.forEach(element => removeKeyEvent(element));\n  });\n};\n\n// \u5BF9\u76D1\u542C\u5BF9\u5E94\u5FEB\u6377\u952E\u7684\u56DE\u8C03\u51FD\u6570\u8FDB\u884C\u5904\u7406\nfunction eventHandler(event, handler, scope, element) {\n  if (handler.element !== element) {\n    return;\n  }\n  let modifiersMatch;\n\n  // \u770B\u5B83\u662F\u5426\u5728\u5F53\u524D\u8303\u56F4\n  if (handler.scope === scope || handler.scope === 'all') {\n    // \u68C0\u67E5\u662F\u5426\u5339\u914D\u4FEE\u9970\u7B26\uFF08\u5982\u679C\u6709\u8FD4\u56DEtrue\uFF09\n    modifiersMatch = handler.mods.length > 0;\n    for (const y in _mods) {\n      if (Object.prototype.hasOwnProperty.call(_mods, y)) {\n        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {\n          modifiersMatch = false;\n        }\n      }\n    }\n\n    // \u8C03\u7528\u5904\u7406\u7A0B\u5E8F\uFF0C\u5982\u679C\u662F\u4FEE\u9970\u952E\u4E0D\u505A\u5904\u7406\n    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {\n      handler.keys = [];\n      handler.keys = handler.keys.concat(_downKeys);\n      if (handler.method(event, handler) === false) {\n        if (event.preventDefault) event.preventDefault();else event.returnValue = false;\n        if (event.stopPropagation) event.stopPropagation();\n        if (event.cancelBubble) event.cancelBubble = true;\n      }\n    }\n  }\n}\n\n// \u5904\u7406keydown\u4E8B\u4EF6\nfunction dispatch(event, element) {\n  const asterisk = _handlers['*'];\n  let key = event.keyCode || event.which || event.charCode;\n\n  // \u8868\u5355\u63A7\u4EF6\u8FC7\u6EE4 \u9ED8\u8BA4\u8868\u5355\u63A7\u4EF6\u4E0D\u89E6\u53D1\u5FEB\u6377\u952E\n  if (!hotkeys.filter.call(this, event)) return;\n\n  // Gecko(Firefox)\u7684command\u952E\u503C224\uFF0C\u5728Webkit(Chrome)\u4E2D\u4FDD\u6301\u4E00\u81F4\n  // Webkit\u5DE6\u53F3 command \u952E\u503C\u4E0D\u4E00\u6837\n  if (key === 93 || key === 224) key = 91;\n\n  /**\n   * Collect bound keys\n   * If an Input Method Editor is processing key input and the event is keydown, return 229.\n   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229\n   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html\n   */\n  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);\n  /**\n   * Jest test cases are required.\n   * ===============================\n   */\n  ['metaKey', 'ctrlKey', 'altKey', 'shiftKey'].forEach(keyName => {\n    const keyNum = modifierMap[keyName];\n    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {\n      _downKeys.push(keyNum);\n    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {\n      _downKeys.splice(_downKeys.indexOf(keyNum), 1);\n    } else if (keyName === 'metaKey' && event[keyName]) {\n      // \u5982\u679Ccommand\u88AB\u6309\u4E0B\uFF0C\u90A3\u5C31\u6E05\u7A7A\u6240\u6709\u9664event\u6309\u952E\u5916\u7684\u975E\u88C5\u9970\u952E\u3002\n      // \u56E0\u4E3Acommand\u88AB\u6309\u4E0B\u7684\u60C5\u51B5\u4E0B\u975E\u88C5\u9970\u952E\u7684keyup\u6C38\u8FDC\u90FD\u4E0D\u4F1A\u89E6\u53D1\u3002\u8FD9\u662F\u5DF2\u77E5\u7684\u6D4F\u89C8\u5668\u9650\u5236\u3002\n      // If command key is pressed, clear all non-decorating keys except for key in event.\n      // This is because keyup for a non-decorating key will NEVER be triggered when command is pressed.\n      // This is a known browser limitation.\n      _downKeys = _downKeys.filter(k => k in modifierMap || k === key);\n    }\n  });\n  /**\n   * -------------------------------\n   */\n\n  if (key in _mods) {\n    _mods[key] = true;\n\n    // \u5C06\u7279\u6B8A\u5B57\u7B26\u7684key\u6CE8\u518C\u5230 hotkeys \u4E0A\n    for (const k in _modifier) {\n      if (_modifier[k] === key) hotkeys[k] = true;\n    }\n    if (!asterisk) return;\n  }\n\n  // \u5C06 modifierMap \u91CC\u9762\u7684\u4FEE\u9970\u952E\u7ED1\u5B9A\u5230 event \u4E2D\n  for (const e in _mods) {\n    if (Object.prototype.hasOwnProperty.call(_mods, e)) {\n      _mods[e] = event[modifierMap[e]];\n    }\n  }\n  /**\n   * https://github.com/jaywcjlove/hotkeys/pull/129\n   * This solves the issue in Firefox on Windows where hotkeys corresponding to special characters would not trigger.\n   * An example of this is ctrl+alt+m on a Swedish keyboard which is used to type \u03BC.\n   * Browser support: https://caniuse.com/#feat=keyboardevent-getmodifierstate\n   */\n  if (event.getModifierState && !(event.altKey && !event.ctrlKey) && event.getModifierState('AltGraph')) {\n    if (_downKeys.indexOf(17) === -1) {\n      _downKeys.push(17);\n    }\n    if (_downKeys.indexOf(18) === -1) {\n      _downKeys.push(18);\n    }\n    _mods[17] = true;\n    _mods[18] = true;\n  }\n\n  // \u83B7\u53D6\u8303\u56F4 \u9ED8\u8BA4\u4E3A `all`\n  const scope = getScope();\n  // \u5BF9\u4EFB\u4F55\u5FEB\u6377\u952E\u90FD\u9700\u8981\u505A\u7684\u5904\u7406\n  if (asterisk) {\n    for (let i = 0; i < asterisk.length; i++) {\n      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {\n        eventHandler(event, asterisk[i], scope, element);\n      }\n    }\n  }\n  // key \u4E0D\u5728 _handlers \u4E2D\u8FD4\u56DE\n  if (!(key in _handlers)) return;\n  const handlerKey = _handlers[key];\n  const keyLen = handlerKey.length;\n  for (let i = 0; i < keyLen; i++) {\n    if (event.type === 'keydown' && handlerKey[i].keydown || event.type === 'keyup' && handlerKey[i].keyup) {\n      if (handlerKey[i].key) {\n        const record = handlerKey[i];\n        const {\n          splitKey\n        } = record;\n        const keyShortcut = record.key.split(splitKey);\n        const _downKeysCurrent = []; // \u8BB0\u5F55\u5F53\u524D\u6309\u952E\u952E\u503C\n        for (let a = 0; a < keyShortcut.length; a++) {\n          _downKeysCurrent.push(code(keyShortcut[a]));\n        }\n        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {\n          // \u627E\u5230\u5904\u7406\u5185\u5BB9\n          eventHandler(event, record, scope, element);\n        }\n      }\n    }\n  }\n}\nfunction hotkeys(key, option, method) {\n  _downKeys = [];\n  const keys = getKeys(key); // \u9700\u8981\u5904\u7406\u7684\u5FEB\u6377\u952E\u5217\u8868\n  let mods = [];\n  let scope = 'all'; // scope\u9ED8\u8BA4\u4E3Aall\uFF0C\u6240\u6709\u8303\u56F4\u90FD\u6709\u6548\n  let element = document; // \u5FEB\u6377\u952E\u4E8B\u4EF6\u7ED1\u5B9A\u8282\u70B9\n  let i = 0;\n  let keyup = false;\n  let keydown = true;\n  let splitKey = '+';\n  let capture = false;\n  let single = false; // \u5355\u4E2Acallback\n\n  // \u5BF9\u4E3A\u8BBE\u5B9A\u8303\u56F4\u7684\u5224\u65AD\n  if (method === undefined && typeof option === 'function') {\n    method = option;\n  }\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    if (option.scope) scope = option.scope; // eslint-disable-line\n    if (option.element) element = option.element; // eslint-disable-line\n    if (option.keyup) keyup = option.keyup; // eslint-disable-line\n    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line\n    if (option.capture !== undefined) capture = option.capture; // eslint-disable-line\n    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line\n    if (option.single === true) single = true; // eslint-disable-line\n  }\n  if (typeof option === 'string') scope = option;\n\n  // \u5982\u679C\u53EA\u5141\u8BB8\u5355\u4E2Acallback\uFF0C\u5148unbind\n  if (single) unbind(key, scope);\n\n  // \u5BF9\u4E8E\u6BCF\u4E2A\u5FEB\u6377\u952E\u8FDB\u884C\u5904\u7406\n  for (; i < keys.length; i++) {\n    key = keys[i].split(splitKey); // \u6309\u952E\u5217\u8868\n    mods = [];\n\n    // \u5982\u679C\u662F\u7EC4\u5408\u5FEB\u6377\u952E\u53D6\u5F97\u7EC4\u5408\u5FEB\u6377\u952E\n    if (key.length > 1) mods = getMods(_modifier, key);\n\n    // \u5C06\u975E\u4FEE\u9970\u952E\u8F6C\u5316\u4E3A\u952E\u7801\n    key = key[key.length - 1];\n    key = key === '*' ? '*' : code(key); // *\u8868\u793A\u5339\u914D\u6240\u6709\u5FEB\u6377\u952E\n\n    // \u5224\u65ADkey\u662F\u5426\u5728_handlers\u4E2D\uFF0C\u4E0D\u5728\u5C31\u8D4B\u4E00\u4E2A\u7A7A\u6570\u7EC4\n    if (!(key in _handlers)) _handlers[key] = [];\n    _handlers[key].push({\n      keyup,\n      keydown,\n      scope,\n      mods,\n      shortcut: keys[i],\n      method,\n      key: keys[i],\n      splitKey,\n      element\n    });\n  }\n  // \u5728\u5168\u5C40document\u4E0A\u8BBE\u7F6E\u5FEB\u6377\u952E\n  if (typeof element !== 'undefined' && window) {\n    if (!elementEventMap.has(element)) {\n      const keydownListener = function () {\n        let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;\n        return dispatch(event, element);\n      };\n      const keyupListenr = function () {\n        let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.event;\n        dispatch(event, element);\n        clearModifier(event);\n      };\n      elementEventMap.set(element, {\n        keydownListener,\n        keyupListenr,\n        capture\n      });\n      addEvent(element, 'keydown', keydownListener, capture);\n      addEvent(element, 'keyup', keyupListenr, capture);\n    }\n    if (!winListendFocus) {\n      const listener = () => {\n        _downKeys = [];\n      };\n      winListendFocus = {\n        listener,\n        capture\n      };\n      addEvent(window, 'focus', listener, capture);\n    }\n  }\n}\nfunction trigger(shortcut) {\n  let scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'all';\n  Object.keys(_handlers).forEach(key => {\n    const dataList = _handlers[key].filter(item => item.scope === scope && item.shortcut === shortcut);\n    dataList.forEach(data => {\n      if (data && data.method) {\n        data.method();\n      }\n    });\n  });\n}\n\n// \u9500\u6BC1\u4E8B\u4EF6,unbind\u4E4B\u540E\u5224\u65ADelement\u4E0A\u662F\u5426\u8FD8\u6709\u952E\u76D8\u5FEB\u6377\u952E\uFF0C\u5982\u679C\u6CA1\u6709\u79FB\u9664\u76D1\u542C\nfunction removeKeyEvent(element) {\n  const values = Object.values(_handlers).flat();\n  const findindex = values.findIndex(_ref4 => {\n    let {\n      element: el\n    } = _ref4;\n    return el === element;\n  });\n  if (findindex < 0) {\n    const {\n      keydownListener,\n      keyupListenr,\n      capture\n    } = elementEventMap.get(element) || {};\n    if (keydownListener && keyupListenr) {\n      removeEvent(element, 'keyup', keyupListenr, capture);\n      removeEvent(element, 'keydown', keydownListener, capture);\n      elementEventMap.delete(element);\n    }\n  }\n  if (values.length <= 0 || elementEventMap.size <= 0) {\n    // \u79FB\u9664\u6240\u6709\u7684\u5143\u7D20\u4E0A\u7684\u76D1\u542C\n    const eventKeys = Object.keys(elementEventMap);\n    eventKeys.forEach(el => {\n      const {\n        keydownListener,\n        keyupListenr,\n        capture\n      } = elementEventMap.get(el) || {};\n      if (keydownListener && keyupListenr) {\n        removeEvent(el, 'keyup', keyupListenr, capture);\n        removeEvent(el, 'keydown', keydownListener, capture);\n        elementEventMap.delete(el);\n      }\n    });\n    // \u6E05\u7A7A elementEventMap\n    elementEventMap.clear();\n    // \u6E05\u7A7A _handlers\n    Object.keys(_handlers).forEach(key => delete _handlers[key]);\n    // \u79FB\u9664window\u4E0A\u7684focus\u76D1\u542C\n    if (winListendFocus) {\n      const {\n        listener,\n        capture\n      } = winListendFocus;\n      removeEvent(window, 'focus', listener, capture);\n      winListendFocus = null;\n    }\n  }\n}\nconst _api = {\n  getPressedKeyString,\n  setScope,\n  getScope,\n  deleteScope,\n  getPressedKeyCodes,\n  getAllKeyCodes,\n  isPressed,\n  filter,\n  trigger,\n  unbind,\n  keyMap: _keyMap,\n  modifier: _modifier,\n  modifierMap\n};\nfor (const a in _api) {\n  if (Object.prototype.hasOwnProperty.call(_api, a)) {\n    hotkeys[a] = _api[a];\n  }\n}\nif (typeof window !== 'undefined') {\n  const _hotkeys = window.hotkeys;\n  hotkeys.noConflict = deep => {\n    if (deep && window.hotkeys === hotkeys) {\n      window.hotkeys = _hotkeys;\n    }\n    return hotkeys;\n  };\n  window.hotkeys = hotkeys;\n}\n\nexport { hotkeys as default };\n", "// @ts-check\n/**\n * import(\"../types/index.d.ts\")\n * import(\"../types/fzy.d.ts\")\n */\n\nimport {BaseElement} from './base-element.js';\nimport {html} from 'lit';\nimport {repeat} from 'lit/directives/repeat.js';\nimport {live} from 'lit/directives/live.js';\nimport {createRef, ref} from 'lit/directives/ref.js';\nimport {classMap} from 'lit/directives/class-map.js';\nimport _hotkeys from 'hotkeys-js';\n\nimport {NinjaHeader} from './ninja-header.js';\nimport {NinjaAction} from './ninja-action.js';\nimport {footerHtml} from './ninja-footer.js';\nimport {baseStyles, componentReset} from './base-styles.js';\n\nimport * as fzy from 'fzy.js';\nimport {escapeStringRegexp} from '../internal/escape-string-regexp.js';\n\n/** @type {import(\"hotkeys-js\").Hotkeys} */\n// @ts-expect-error Gets proper types for hotkeys.\nconst hotkeys = _hotkeys;\n\n/** @typedef {import(\"./ninja-header.js\").NinjaHeader} NinjaHeaderElement */\n/** @typedef {import(\"../types/index.d.ts\").INinjaAction} INinjaAction */\n/** @typedef {import(\"../types/index.d.ts\").INinjaActionData} INinjaActionData */\n\n/**\n * @type BaseElement\n */\nexport class NinjaKeys extends BaseElement {\n  /**\n   * @override\n   */\n  static baseName = 'ninja-keys';\n\n  /**\n   * @override\n   */\n  static get scopedElements() {\n    return {\n      'ninja-action': NinjaAction,\n      'ninja-header': NinjaHeader,\n    };\n  }\n\n  /**\n   * @override\n   */\n  static styles = [componentReset, baseStyles];\n\n  /**\n   * @override\n   */\n  static properties = {\n    placeholder: {type: String},\n    disableHotkeys: {type: Boolean},\n    searchType: {attribute: 'search-type'},\n    searchLabel: {attribute: 'search-label'},\n    listboxLabel: {attribute: 'listbox-label'},\n    hideBreadcrumbs: {type: Boolean},\n    openHotkey: {},\n    navigationUpHotkey: {},\n    navigationDownHotkey: {},\n    closeHotkey: {},\n    goBackHotkey: {},\n    selectHotkey: {},\n    hotKeysJoinedView: {type: Boolean},\n    noAutoLoadMdIcons: {type: Boolean},\n    data: {\n      type: Array,\n      hasChanged() {\n        // Forced to trigger changed event always.\n        // Because of a lot of framework pattern wrap object with an Observer, like vue2.\n        // That's why object passed to web component always same and no render triggered. Issue #9\n        return true;\n      },\n    },\n    highlightMatches: {\n      type: Boolean,\n      reflect: true,\n      attribute: 'highlight-matches',\n    },\n\n    // State\n    __selected__: {state: true},\n    visible: {state: true},\n    _bump: {state: true},\n    _actionMatches: {state: true},\n    _search: {state: true},\n    currentRoot: {state: true},\n    _flatData: {state: true},\n  };\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    super();\n\n    /**\n     * @type {import(\"lit/directives/ref.js\").Ref<NinjaHeaderElement>}\n     */\n    this._headerRef = createRef();\n\n    /**\n     * Search placeholder text\n     * @type {string}\n     */\n    this.placeholder = 'Type a command or search...';\n\n    /**\n     * If true will register all hotkey for all actions\n     * @type {boolean}\n     */\n    this.disableHotkeys = false;\n\n    /**\n     * @type {\"regex\" | \"fuzzy\"}\n     */\n    this.searchType = 'regex';\n\n    /**\n     * Whether or not to turn on match highlighting\n     * @type {boolean}\n     */\n    this.highlightMatches = false;\n\n    /**\n     * Maps to `aria-labelledby` for search input\n     * @type {string}\n     */\n    this.searchLabel = 'Search for actions';\n\n    /**\n     * Maps to `aria-labelledby` for listbox\n     * @type {string}\n     */\n    this.listboxLabel = 'List of actions';\n\n    /**\n     * Show or hide breadcrumbs on header\n     * @type {boolean}\n     */\n    this.hideBreadcrumbs = false;\n\n    /**\n     * Open or hide shorcut\n     * @type {string}\n     */\n    this.openHotkey = 'cmd+k,ctrl+k';\n\n    /**\n     * Navigation Up hotkey\n     * @type {string}\n     */\n    this.navigationUpHotkey = 'up';\n\n    /**\n     * Navigation Down hotkey\n     * @type {string}\n     */\n    this.navigationDownHotkey = 'down';\n\n    /**\n     * Close hotkey\n     * @type {string}\n     */\n    this.closeHotkey = 'esc';\n\n    /**\n     * Go back on one level if has parent menu\n     * @type {string}\n     */\n    this.goBackHotkey = 'backspace';\n\n    /**\n     * Select action and execute handler or open submenu\n     * @type {string}\n     */\n    this.selectHotkey = 'enter'; // enter,space\n\n    /**\n     * Show or hide breadcrumbs on header\n     * @type {boolean}\n     */\n    this.hotKeysJoinedView = false;\n\n    /**\n     * Disable load material icons font on connect\n     * If you use custom icons.\n     * Set this attribute to prevent load default icons font\n     * @type {boolean}\n     */\n    this.noAutoLoadMdIcons = false;\n\n    /**\n     * Array of actions\n     * @type {Array<INinjaAction>}\n     */\n    this.data = [];\n\n    /**\n     * Private\n     */\n\n    /**\n     * @private\n     * @type {import('../types/index.js').Maybe<INinjaAction>}\n     */\n    this.__selected__ = null;\n\n    /**\n     * Show or hide element\n     * @type {boolean}\n     */\n    this.visible = false;\n\n    /**\n     * Temporarily used for animation effect. TODO: change to animate logic\n     * @private\n     * @type {boolean}\n     */\n    this._bump = true;\n\n    /**\n     * @private\n     * @type {Array<INinjaAction>}\n     */\n    this._actionMatches = [];\n\n    /**\n     * @type {string}\n     */\n    this._search = '';\n\n    /**\n     * @public\n     * @type {undefined | string}\n     */\n    this.currentRoot = undefined;\n\n    /**\n     * Array of actions in flat structure\n     * @type {Array<INinjaAction>}\n     */\n    this._flatData = [];\n  }\n\n  /**\n   * Public methods\n   */\n\n  /**\n   * Show a modal\n   * @param {{ parent?: string }} [options={}]\n   */\n  open(options = {}) {\n    this._bump = true;\n    this.visible = true;\n    const header = this._headerRef.value;\n\n    requestAnimationFrame(() => {\n      if (header) {\n        header.focusSearch();\n        header.expanded = true;\n        header.controls = 'actions-list';\n      }\n    });\n\n    if (this._actionMatches.length > 0) {\n      this._selected = this._actionMatches[0];\n\n      const header = this._headerRef.value;\n      if (header && this._selected && this._selected.id) {\n        header.activeDescendant = this._selected.id;\n      }\n    }\n    this.setParent(options.parent);\n  }\n\n  /**\n   * Close modal\n   */\n  close() {\n    this._bump = false;\n    this.visible = false;\n\n    const header = this._headerRef.value;\n    if (header) {\n      header.expanded = false;\n    }\n  }\n\n  /**\n   * Navigate to group of actions\n   * @param {string} [parent] - parent id of parent group/action\n   */\n  setParent(parent) {\n    if (!parent) {\n      this.currentRoot = undefined;\n    } else {\n      this.currentRoot = parent;\n    }\n    this._selected = undefined;\n    this._search = '';\n    this._headerRef.value?.setSearch('');\n  }\n\n  /**\n   * @private\n   */\n  getBreadcrumbs() {\n    const path = [];\n    let parentAction = this._selected?.parent;\n    if (parentAction) {\n      path.push(parentAction);\n      while (parentAction) {\n        const action = this._flatData.find((a) => a.id === parentAction);\n        if (action?.parent) {\n          path.push(action.parent);\n        }\n        parentAction = action ? action.parent : undefined;\n      }\n    }\n    return path.reverse();\n  }\n\n  /**\n   * @returns {import('../types/index.js').Maybe<INinjaAction>}\n   */\n  get _selected() {\n    return this.__selected__;\n  }\n\n  /**\n   * @param {import('../types/index.js').Maybe<INinjaAction>} action\n   */\n  set _selected(action) {\n    const header = this._headerRef.value;\n    if (header && action && action.id) {\n      header.activeDescendant = action.id;\n    }\n    const prevSelection = this.__selected__;\n    this.__selected__ = action;\n    this.requestUpdate('_selected', prevSelection);\n  }\n\n  /**\n   * @override\n   */\n  connectedCallback() {\n    super.connectedCallback();\n\n    if (!this.noAutoLoadMdIcons) {\n      document.fonts.load('24px Material Icons', 'apps').then(() => {});\n    }\n\n    this._registerInternalHotkeys();\n  }\n\n  /**\n   * @override\n   */\n  disconnectedCallback() {\n    super.disconnectedCallback();\n    this._unregisterInternalHotkeys();\n  }\n\n  /**\n   * @private\n   * @param {INinjaActionData[]} data\n   * @returns {INinjaAction[]}\n   */\n  _flattern(data) {\n    /** @type {INinjaActionData[]} */\n    const flattenedTree = [];\n\n    traverse(data);\n\n    /**\n     * @param {INinjaActionData[]} nodes\n     * @param {string} [parent]\n     */\n    function traverse(nodes, parent) {\n      nodes.forEach((node) => {\n        if (parent) node.parent = parent;\n        if (node.children) {\n          const nextNodes = /** @type {INinjaActionData[]} */ ([\n            ...node.children.filter((n) => typeof n !== 'string'),\n          ]);\n\n          node.children = node.children.map((child) =>\n            typeof child === 'string' ? child : child.id || ''\n          );\n\n          traverse(nextNodes, node.id);\n        }\n\n        flattenedTree.push(node);\n      });\n    }\n\n    return /** @type {INinjaAction[]} */ (flattenedTree);\n  }\n\n  /**\n   * @override\n   * @param {import(\"lit\").PropertyValues<this>} changedProperties\n   */\n  update(changedProperties) {\n    if (changedProperties.has('data')) {\n      this._flatData = this._flattern(this.data);\n\n      if (!this.disableHotkeys) {\n        this._flatData.forEach((action) => {\n          if (!action.hotkey) return;\n\n          hotkeys(action.hotkey, (event) => {\n            event.preventDefault();\n            if (action.handler) {\n              action.handler(action, event, this._search);\n            }\n          });\n        });\n      }\n    }\n    super.update(changedProperties);\n  }\n\n  /**\n   * @param {Event} event\n   * @return {Boolean}\n   */\n  shouldNotOpen(event) {\n    /**\n     * @type {Element[]}\n     */\n    // @ts-expect-error EventTarget sucks.\n    const composedPath = event.composedPath();\n\n    const disallowedTags = ['input', 'textarea'];\n\n    return composedPath.some((el) => {\n      if (el?.getAttribute?.('contenteditable') === 'true') {\n        return true;\n      }\n\n      return disallowedTags.includes(el?.tagName?.toLowerCase());\n    });\n  }\n\n  /**\n   * @private\n   */\n  _registerInternalHotkeys() {\n    if (this.openHotkey) {\n      hotkeys(this.openHotkey, (event) => {\n        if (this.shouldNotOpen(event)) {\n          return;\n        }\n\n        event.preventDefault();\n        this.visible ? this.close() : this.open();\n      });\n    }\n\n    if (this.selectHotkey) {\n      hotkeys(this.selectHotkey, (event) => {\n        if (!this.visible) {\n          return;\n        }\n        event.preventDefault();\n        this._actionSelected(this._actionMatches[this._selectedIndex], event);\n      });\n    }\n\n    if (this.goBackHotkey) {\n      hotkeys(this.goBackHotkey, (event) => {\n        if (!this.visible) {\n          return;\n        }\n\n        if (!this._search) {\n          event.preventDefault();\n          this._goBack();\n        }\n      });\n    }\n\n    if (this.navigationDownHotkey) {\n      hotkeys(this.navigationDownHotkey, (event) => {\n        if (!this.visible) {\n          return;\n        }\n        event.preventDefault();\n        if (this._selectedIndex >= this._actionMatches.length - 1) {\n          this._selected = this._actionMatches[0];\n        } else {\n          this._selected = this._actionMatches[this._selectedIndex + 1];\n        }\n      });\n    }\n\n    if (this.navigationUpHotkey) {\n      hotkeys(this.navigationUpHotkey, (event) => {\n        if (!this.visible) {\n          return;\n        }\n        event.preventDefault();\n        if (this._selectedIndex === 0) {\n          this._selected = this._actionMatches[this._actionMatches.length - 1];\n        } else {\n          this._selected = this._actionMatches[this._selectedIndex - 1];\n        }\n      });\n    }\n\n    if (this.closeHotkey) {\n      hotkeys(this.closeHotkey, (e) => {\n        if (!this.visible) {\n          return;\n        }\n\n        e.preventDefault();\n        this.visible = false;\n        this.close();\n      });\n    }\n  }\n\n  /**\n   * @private\n   */\n  _unregisterInternalHotkeys() {\n    if (this.openHotkey) {\n      hotkeys.unbind(this.openHotkey);\n    }\n\n    if (this.selectHotkey) {\n      hotkeys.unbind(this.selectHotkey);\n    }\n\n    if (this.goBackHotkey) {\n      hotkeys.unbind(this.goBackHotkey);\n    }\n\n    if (this.navigationDownHotkey) {\n      hotkeys.unbind(this.navigationDownHotkey);\n    }\n\n    if (this.navigationUpHotkey) {\n      hotkeys.unbind(this.navigationUpHotkey);\n    }\n\n    if (this.closeHotkey) {\n      hotkeys.unbind(this.closeHotkey);\n    }\n  }\n\n  /**\n   * @private\n   * @param {INinjaAction} index\n   * @param {MouseEvent} $event\n   */\n  _actionFocused(index, $event) {\n    // this.selectedIndex = index;\n    this._selected = index;\n\n    /** @type {import(\"./index.js\").NinjaAction} */\n    // @ts-expect-error we know its a ninja action.\n    const target = $event.target;\n    target.ensureInView();\n  }\n\n  /** @private */\n  _onTransitionEnd() {\n    this._bump = false;\n  }\n\n  /**\n   * @deprecated\n   * This is a convenience function to align with the previous API.\n   * Don't use this to pass to templates because I've found it create inconsistent behavior.\n   * Use `this.getBreadcrumbs()` instead.\n   */\n  get breadcrumbs() {\n    return this.getBreadcrumbs();\n  }\n\n  /**\n   * @private\n   */\n  _goBack() {\n    const breadcrumbs = this.getBreadcrumbs();\n    if (breadcrumbs) {\n      const parent =\n        breadcrumbs.length > 1\n          ? breadcrumbs[breadcrumbs.length - 2]\n          : undefined;\n      this.setParent(parent);\n      return;\n    }\n  }\n\n  /**\n   * @returns {NinjaAction | null | undefined}\n   */\n  findActionElement(index = this._selectedIndex) {\n    const id = this._actionMatches[index]?.id;\n\n    if (id == null) return null;\n\n    const query = '#ninja-action__' + id;\n\n    return this.shadowRoot?.querySelector(query);\n  }\n\n  /**\n   * @public\n   * Escapes invalid string sequences when calling `new RegExp(string)`. This is used for `findMatches`.\n   * @see {@link https://github.com/ssleptsov/ninja-keys/pull/33}\n   * @param {string} str\n   */\n  stringToRegExp(str) {\n    return escapeStringRegexp(str);\n  }\n\n  /**\n   * Iterates over flatData to find a match. Override this if you want to implement your own matcher.\n   * If you're using search from a different place and adding / removing results, just return\n   * the flatData.\n   * @param {Array<INinjaAction>} flatData\n   */\n  findMatches(flatData) {\n    // https://stackoverflow.com/questions/31814535/getting-error-invalid-regular-expression\n    const searchRegex = this.stringToRegExp(this._search);\n\n    const searchOptions = {\n      searchRegex,\n      searchString: this._search,\n    };\n\n    return flatData.filter((action) => {\n      if (this._search.trim() === '') {\n        return action.parent === this.currentRoot && true;\n      }\n\n      const {matcher, title, keywords, content} = action;\n\n      let isMatch = null;\n\n      if (typeof matcher === 'function') {\n        isMatch = matcher(action, searchOptions);\n      }\n\n      if (\n        (isMatch == null && !this.searchType) ||\n        this.searchType === 'regex'\n      ) {\n        // @TODO: At some point if we ever want to support sorting based on \"boosting\" we may need a separate \"searchType\",\n        // or we could provide \"intrinsic\" boosts users can override.\n        isMatch = Boolean(\n          (title && title.match(searchRegex)) ||\n            (keywords && keywords.match(searchRegex)) ||\n            (content && content.match(searchRegex))\n        );\n      }\n\n      if (isMatch == null && this.searchType === 'fuzzy') {\n        const search = this._search;\n\n        // @TODO: At some point if we ever want to support sorting based on \"boosting\" we may need a separate \"searchType\"\n        // or we could provide \"intrinsic\" boosts users can override.\n        isMatch = Boolean(\n          (title && hasMatch(search, title)) ||\n            (keywords && hasMatch(search, keywords)) ||\n            (content && hasMatch(search, content))\n        );\n      }\n\n      if (isMatch == null) {\n        isMatch = Boolean(isMatch);\n      }\n\n      if (!this.currentRoot && this._search) {\n        // global search for items on root\n        return isMatch;\n      }\n\n      return action.parent === this.currentRoot && isMatch;\n    });\n  }\n\n  /**\n   * @override\n   */\n  render() {\n    const classes = {\n      bump: this._bump,\n      'modal-content': true,\n    };\n\n    const menuClasses = {\n      visible: this.visible,\n      modal: true,\n    };\n\n    let sections;\n    let actionMatches = this._flatData;\n\n    actionMatches = this.findMatches(actionMatches);\n\n    sections = actionMatches.reduce(\n      (entryMap, e) =>\n        entryMap.set(e.section, [...(entryMap.get(e.section) || []), e]),\n      new Map()\n    );\n\n    this._actionMatches = [...sections.values()].flat();\n\n    if (this._actionMatches.length > 0 && this._selectedIndex === -1) {\n      this._selected = this._actionMatches[0];\n    }\n    if (this._actionMatches.length === 0) {\n      this._selected = undefined;\n    }\n\n    /**\n     * @param {INinjaAction[]} actions\n     */\n    const actionsList = (actions) =>\n      html` ${repeat(\n        actions,\n        (action) => action.id,\n        (action) =>\n          html`<ninja-action\n            id=${'ninja-action__' + action.id}\n            role=\"option\"\n            exportparts=\"ninja-action, ninja-selected,ninja-icon, ninja-hotkeys, ninja-hotkey, ninja-action__header, ninja-action__title, ninja-action__content, ninja-action__highlight\"\n            aria-selected=${live(action.id === this._selected?.id)}\n            .searchQuery=${this._search}\n            .selected=${live(action.id === this._selected?.id)}\n            .hotKeysJoinedView=${this.hotKeysJoinedView}\n            .searchType=${this.searchType}\n            .highlightMatches=${this.highlightMatches}\n            tabindex=\"-1\"\n            @mousemove=${(/** @type {MouseEvent} */ event) => {\n              this._actionFocused(action, event);\n            }}\n            @actionsSelected=${(\n              /** @type {CustomEvent<INinjaAction>}*/ event\n            ) => this._actionSelected(event.detail, event)}\n            .action=${action}\n          ></ninja-action>`\n      )}`;\n\n    /**\n     * @type {import(\"lit\").TemplateResult[]}\n     */\n    const itemTemplates = [];\n    sections.forEach((actions, section) => {\n      const header = section\n        ? html`<div class=\"group-header\">${section}</div>`\n        : undefined;\n      itemTemplates.push(html`${header}${actionsList(actions)}`);\n    });\n\n    return html`\n      <div\n        part=\"modal-overlay\"\n        @click=${this._overlayClick}\n        class=${classMap(menuClasses)}\n      >\n        <div\n          part=\"modal-content\"\n          class=${classMap(classes)}\n          @animationend=${this._onTransitionEnd}\n        >\n          <ninja-header\n            part=\"modal-header\"\n            exportparts=\"ninja-input,ninja-input-wrapper\"\n            ${ref(this._headerRef)}\n            .placeholder=${this.placeholder}\n            .hideBreadcrumbs=${this.hideBreadcrumbs}\n            .breadcrumbs=${this.getBreadcrumbs()}\n            searchLabel=${this.searchLabel}\n            @change=${this._handleInput}\n            @setParent=${(/** @type {CustomEvent<INinjaAction>} */ event) =>\n              this.setParent(event.detail.parent)}\n            @close=${this.close}\n          >\n          </ninja-header>\n          <div part=\"modal-body\" class=\"modal-body\">\n            <div\n              id=\"actions-list\"\n              class=\"actions-list\"\n              role=\"listbox\"\n              part=\"actions-list\"\n              aria-labelledby=\"listbox-label\"\n            >\n              ${itemTemplates}\n            </div>\n\n            <label id=\"listbox-label\" class=\"visually-hidden\">\n              <slot>\n                <span>${this.listboxLabel}</span>\n              </slot>\n            </label>\n            <slot name=\"footer\"> ${footerHtml} </slot>\n          </div>\n        </div>\n      </div>\n    `;\n  }\n\n  /**\n   * @private\n   * @returns {number}\n   */\n  get _selectedIndex() {\n    if (!this._selected) {\n      return -1;\n    }\n    return this._actionMatches.indexOf(this._selected);\n  }\n\n  /**\n   * @private\n   * @param {INinjaAction} [action]\n   * @param {KeyboardEvent | CustomEvent<INinjaAction>} [event]\n   */\n  _actionSelected(action, event) {\n    // fire selected event even when action is empty/not selected,\n    // so possible handle api search for example\n    this.dispatchEvent(\n      new CustomEvent('selected', {\n        detail: {search: this._search, action},\n        bubbles: true,\n        composed: true,\n      })\n    );\n\n    if (!action) {\n      return;\n    }\n\n    if (action.children && action.children?.length > 0) {\n      this.currentRoot = action.id;\n    }\n\n    this._search = '';\n    this._headerRef.value?.setSearch('');\n    this._headerRef.value?.focusSearch();\n\n    if (action.handler) {\n      const result = action.handler(action, event, this._search);\n      if (!result?.keepOpen) {\n        this.close();\n      }\n    } else {\n      // Default behavior for links\n      this.findActionElement(this._selectedIndex)?.forceClick();\n    }\n    this._bump = true;\n  }\n\n  /**\n   * @private\n   * @param {CustomEvent<{search: string}>} event\n   */\n  async _handleInput(event) {\n    this._search = event.detail.search;\n    await this.updateComplete;\n    this.dispatchEvent(\n      new CustomEvent('change', {\n        detail: {search: this._search, actions: this._actionMatches},\n        bubbles: true,\n        composed: true,\n      })\n    );\n  }\n\n  /**\n   * @private\n   * @param {Event} event\n   */\n  _overlayClick(event) {\n    const target = event.target;\n\n    if (target instanceof Element) {\n      if (target?.classList.contains('modal')) {\n        this.close();\n      }\n    }\n  }\n}\n\n/**\n * @param {string} query\n * @param {string} str\n * @returns {boolean}\n */\nfunction hasMatch(query, str) {\n  return [query, ...query.split(/\\s+/)].some((q) => fzy.hasMatch(q, str));\n}\n"],
  "mappings": "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",
  "names": ["generateMap", "list", "start", "end", "map", "Map", "i", "set", "repeat", "directive", "Directive", "partInfo", "super", "type", "PartType", "CHILD", "Error", "items", "keyFnOrTemplate", "template", "keyFn", "keys", "values", "index", "item", "this", "_getValuesAndKeys", "containerPart", "oldParts", "getCommittedValue", "newValues", "newKeys", "Array", "isArray", "_itemKeys", "oldKeys", "newParts", "newKeyToIndexMap", "oldKeyToIndexMap", "oldHead", "oldTail", "length", "newHead", "newTail", "setChildPartValue", "insertPart", "has", "oldIndex", "get", "oldPart", "newPart", "removePart", "setCommittedValue", "noChange", "live", "directive", "Directive", "partInfo", "super", "type", "PartType", "PROPERTY", "ATTRIBUTE", "BOOLEAN_ATTRIBUTE", "Error", "isSingleExpression", "value", "part", "noChange", "nothing", "element", "name", "hasAttribute", "getAttribute", "String", "setCommittedValue", "isff", "addEvent", "object", "event", "method", "useCapture", "removeEvent", "getMods", "modifier", "key", "mods", "getKeys", "keys", "index", "compareArray", "a1", "a2", "arr1", "arr2", "isIndex", "i", "_keyMap", "_modifier", "modifierMap", "_mods", "_handlers", "k", "_downKeys", "winListendFocus", "_scope", "elementEventMap", "code", "x", "getKey", "getModifier", "setScope", "scope", "getScope", "getPressedKeyCodes", "getPressedKeyString", "c", "getAllKeyCodes", "result", "_ref", "shortcut", "v", "filter", "target", "tagName", "flag", "isInput", "isPressed", "keyCode", "deleteScope", "newScope", "handlers", "_ref2", "element", "removeKeyEvent", "clearModifier", "hotkeys", "unbind", "keysInfo", "info", "eachUnbind", "_len", "args", "_key", "_ref3", "splitKey", "originKey", "unbindKeys", "len", "lastKey", "unbindElements", "record", "isUnbind", "eventHandler", "handler", "modifiersMatch", "y", "dispatch", "asterisk", "keyName", "keyNum", "e", "handlerKey", "keyLen", "keyShortcut", "_downKeysCurrent", "a", "option", "keyup", "keydown", "capture", "single", "keydownListener", "keyupListenr", "listener", "trigger", "item", "data", "values", "_ref4", "el", "_api", "_hotkeys", "deep", "hotkeys", "NinjaKeys", "BaseElement", "NinjaAction", "NinjaHeader", "e", "options", "header", "parent", "path", "parentAction", "action", "a", "prevSelection", "data", "flattenedTree", "traverse", "nodes", "node", "nextNodes", "n", "child", "changedProperties", "event", "composedPath", "disallowedTags", "el", "index", "$event", "breadcrumbs", "id", "query", "str", "escapeStringRegexp", "flatData", "searchRegex", "searchOptions", "matcher", "title", "keywords", "content", "isMatch", "search", "hasMatch", "classes", "menuClasses", "sections", "actionMatches", "entryMap", "actionsList", "actions", "x", "c", "l", "itemTemplates", "section", "footerHtml", "target", "__publicField", "componentReset", "baseStyles", "q"]
}
